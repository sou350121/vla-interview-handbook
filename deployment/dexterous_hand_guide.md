# 灵巧手落地实战指南 (Dexterous Hand Deployment Guide) - 进阶版

> **"Show me the code, and the scars."**
> 之前的版本是给项目经理看的，这个版本是给在现场熬夜调试的工程师看的。这里没有漂亮的废话，只有血淋淋的教训。

## 1. 底层通信：不仅是连上，是要 "稳"

### 1.1 实时内核 (Real-time Kernel) 是必须的
不要指望标准的 Linux 内核能稳定跑 500Hz 的控制环。
- **现象**: 机械臂平时很顺，偶尔突然 "抽搐" 一下。
- **原因**: 操作系统调度延迟 (Jitter)。标准内核的调度延迟可能高达 10ms+。
- **解决方案**:
    1. **打 PREEMPT_RT 补丁**: 将内核抢占模式改为 `Fully Preemptible Kernel (RT)`。
    2. **CPU 隔离 (isolcpus)**: 在 `grub` 中配置 `isolcpus=2,3`，将控制线程绑定到被隔离的 CPU 核上，避免被 UI 或其他进程打断。
    3. **设置优先级**: 使用 `chrt` 将控制进程的优先级拉到最高 (e.g., `chrt -f 99 ./control_loop`)。

### 1.2 CAN 总线的 "玄学" 调试
灵巧手最常见的死法是 "CAN Bus Off"。
- **终端电阻 (120Ω)**: 
    - **小白错误**: 没接电阻，或者接了两个导致阻值变成 60Ω。
    - **老鸟经验**: 用万用表量 CAN_H 和 CAN_L 之间的电阻。**必须是 60Ω 左右** (两个 120Ω 并联)。如果是在机械臂末端，通常需要一个专门的终端电阻插头。
- **共地问题 (Common Ground)**:
    - **现象**: 通信时断时续，或者摸一下机器人就报错。
    - **原因**: 灵巧手供电地 (GND) 和 CAN 卡的地电位差过大。
    - **解决**: 务必保证 CAN 信号的地与电源地共地，或者使用**带光耦隔离**的 CAN 卡。
- **调试神器**: `candump` 和 `can-utils`。
    - `candump can0 -e`: 查看错误帧。如果你看到大量的 `ERRORFRAME`，先别查代码，查接线。
    - `ip -d link show can0`: 查看总线负载和错误计数。

## 2. 机械与维护：由于 "物理" 导致的算法失效

### 2.1 腱绳 (Tendon) 的松弛与断裂
对于因时/Shadow 这种线驱动的手：
- **迟滞 (Hysteresis)**: 刚买来时很准，用了一周发现控制精度变差，回零回不到位。
- **原因**: 腱绳被拉长了 (Creep)。
- **维护**: 
    - **定期张紧**: 每周检查一次腱绳张力。
    - **软件补偿**: 在算法层加入 "死区补偿" (Backlash Compensation)。当电机反向转动时，先空转一段距离吃掉松弛，再进行力控。

### 2.2 硅胶指尖的磨损
- **现象**: 同样的抓取策略，以前能抓起杯子，现在老是滑落。
- **原因**: 指尖硅胶垫磨损，摩擦系数 $\mu$ 从 1.0 降到了 0.5。
- **解决**: 
    - **耗材管理**: 硅胶垫是耗材！多备几套。
    - **算法鲁棒性**: 训练时 Domain Randomization 的摩擦系数下限要设得足够低 (e.g., 0.3)，逼迫策略学会 "包络抓取" (Power Grasp) 而不是仅依赖指尖摩擦的 "捏取" (Pinch Grasp)。

## 3. 供电与热管理：炸机之源

### 3.1 瞬间反电动势 (Back-EMF)
- **场景**: 灵巧手用力抓握时突然松开，或者被外力猛烈撞击。
- **后果**: 电机产生巨大的反电动势，电压瞬间飙升 (e.g., 24V -> 60V)，击穿主板电容或烧毁前端 CAN 卡。
- **保命措施**: 在电源输入端并联一个 **大电容** 或 **TVS 二极管** (瞬态抑制二极管) 吸收浪涌。

### 3.2 "烫手" 问题
- **现象**: 连续运行 10 分钟后，灵巧手过热保护，直接掉电疲软。
- **软件策略**: 
    - **动态力矩限制**: 建立热模型。$I^2R$ 发热。当估算的温度过高时，线性降低最大允许电流。
    - **Idle State**: 当不需要抓取时，不要维持高刚度位置控制，切换到低增益 (Low Gain) 模式或重力补偿模式，让电机休息。

## 4. 算法集成的 "脏" 活

### 4.1 频率对齐 (Frequency Alignment)
- **问题**: 机械臂 500Hz，灵巧手 100Hz，相机 30Hz。怎么同步？
- **错误做法**: `time.sleep()` 硬等。
- **正确做法**: 
    - **最新状态缓存**: 开启一个高频线程专门读取传感器，写入共享内存/环形缓冲区 (Ring Buffer)。
    - **插值 (Interpolation)**: 控制循环读取缓冲区中最新的数据。对于低频的灵巧手，对其上一帧和当前帧进行线性插值，提供给高频的机械臂控制器 (如果涉及全身动力学)。

### 4.2 延迟测量 (Latency Measurement)
不要猜延迟是多少，要测。
- **方法**: 
    1. 在灵巧手边上放一个高帧率相机 (iPhone 慢动作模式, 240fps)。
    2. LED 连接到上位机 GPIO。
    3. 程序发送 "动" 指令的同时点亮 LED。
    4. 数视频帧：从 LED 亮到手指开始动的帧数差。
- **基准**: 优秀的系统端到端延迟应 < 50ms。如果 > 100ms，VLA 模型基本没法做动态抓取。

## 5. 总结
真实的灵巧手落地，70% 时间在和硬件 bug 搏斗，20% 在写驱动和通信，只有 10% 在调 VLA 模型。
**Respect the Physics.**


---
[← Back to Deployment](./README.md)
